---
layout: post
title: "circular disk cavity"
date: 2024-11-10
categories: blog
excerpt: ""
image: "/study_img/cdc/2.png"
---
<head>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
       <script type="text/x-mathjax-config">
         MathJax.Hub.Config({
           tex2jax: {
             inlineMath: [ ['$','$'], ["\\(","\\)"] ],
             displayMath: [['$$','$$']],
             processEscapes: true
           }
         });
       </script>
       <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

## Whispering Gallery Modes

<img src="/study_img/cdc/4.png" alt="" style="width: 30%; height: auto;"/>

From equation (7) of [Modes of Slab Waveguide] the scalar mode equation can be expressed by

<div style="overflow-x: auto;">
$$
\begin{align}
\nabla^2 \psi(x,y) + n^2 k^2 \psi(x,y) = 0 \tag{1}
\end{align}
$$
</div>

Since the system has rotational symmetry, the ansatz  $\psi(r,\phi) = \Psi(r)e^{im\phi}$ is used.
where the $2\pi$ periodicity implies $m \in \mathbb{Z}$ and can be connected with the slab waveguide propagtion constant as $\beta=\frac{m}{R}$.
Then by assuming $k_z \approx 0$ that propagation in the z-direction is negligible,

<div style="overflow-x: auto;">
$$
\begin{align}
[r^2 \partial^2_r + r\partial_r + (n^2k^2r^2 - m^2)]\Psi = 0 \tag{2}
\end{align}
$$
</div>

is obtained. which is Bessel-like ODE that can be solved independently by Bessel, Hankel an Neumann functions. \\
With outgoing wave condition, the reasonable ansats is

<div style="overflow-x: auto;">
$$
E_{m,l}(r,\phi)=
\begin{cases}
\dfrac{J_m(nkr)}{J_m(nkR)} e^{im\phi}, & r < R, \\[6pt]
\dfrac{H_m(kr)}{H_m(kR)} e^{im\phi}, & r \ge R .
\end{cases}
$$
</div>

where the refractive index outside the cavity is assumed zero.
Now applying the boudary condition for electromagnetic waves yields,

<div style="overflow-x: auto;">
$$
S_m(x) := \frac{n}{\zeta}\,\frac{J_m'(nx)}{J_m(nx)}
          \;-\;
          \frac{H_m'(x)}{H_m(x)}
          = 0 .
$$
</div>

where $x=kR, \zeta=1(n^2)$ for TM(TE) pol.

<img src="/study_img/cdc/3.png" alt="" style="width: 80%; height: auto;"/>

$kR$ values are complex with $\Re(kR)=\frac{2\pi R}{\lambda}, Q=\frac{\Re(kR)}{-2\Im(kR)}$

<img src="/study_img/cdc/1.png" alt="" style="width: 80%; height: auto;"/>


<div id="wgm-container"></div>

<script src="https://cdn.jsdelivr.net/npm/p5@1.11.0/lib/p5.min.js"></script>

<script>
  new p5((p) => {
    let wgmData;
    let mSlider, lSlider;
    let phase = 0;

    const dataPath = "/_posts/blog/wgm_radial.json"; // 업로드한 경로에 맞게 수정

    p.preload = function () {
      wgmData = p.loadJSON(dataPath);
    };

    p.setup = function () {
      const cnv = p.createCanvas(400, 400);
      cnv.parent("wgm-container");
      p.pixelDensity(1);

      const ui = p.createDiv().parent("wgm-container");
      ui.style("margin-top", "8px");
      ui.style("font-family", "sans-serif");
      ui.style("font-size", "14px");

      p.createSpan(" m: ").parent(ui);
      mSlider = p.createSlider(1, 30, 10, 1).parent(ui);

      p.createSpan("  l: ").parent(ui);
      lSlider = p.createSlider(1, 3, 1, 1).parent(ui);

      const desc = p.createP("Python에서 실제 WGM을 계산해 둔 데이터를 시각화합니다.");
      desc.parent("wgm-container");
      desc.style("margin", "4px 0 0 0");
    };

    // r(0~2R)에서 radial 값을 보간
    function sampleRadial(m, l, r) {
      const key = `m${Math.abs(m)}_l${l}`;
      const radialDict = wgmData.radial || {};
      const arr = radialDict[key];
      if (!arr) return 0;

      const R = wgmData.R || 1.0;
      const nr = wgmData.nr || arr.length;
      const rMax = 2 * R;

      if (r <= 0) return arr[0];
      if (r >= rMax) return arr[arr.length - 1];

      const t = r / rMax; // 0~1
      const idx = t * (nr - 1);
      const i0 = Math.floor(idx);
      const i1 = Math.min(i0 + 1, nr - 1);
      const a = idx - i0;

      return arr[i0] * (1 - a) + arr[i1] * a;
    }

    p.draw = function () {
      const m = mSlider.value(); // 여기서 부호 바꿔서 cw/ccw 연출해도 됨
      const l = lSlider.value();
      const R = wgmData.R || 1.0;

      phase += 0.03;

      p.loadPixels();
      const w = p.width;
      const h = p.height;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          // [-2R, 2R] 범위로 정규화된 좌표
          const nx = p.map(x, 0, w, -2 * R, 2 * R);
          const ny = p.map(y, 0, h, -2 * R, 2 * R);

          const r = Math.sqrt(nx * nx + ny * ny);   // 0 ~ 대략 2R
          const phi = Math.atan2(ny, nx);           // -π ~ π

          const radial = sampleRadial(m, l, r);
          const angular = Math.cos(m * phi + phase);
          const E = radial * angular;               // 실수 필드

          let v = 0.5 + 0.5 * E; // [-1,1] -> [0,1]
          v = Math.min(Math.max(v, 0), 1);
          const col = v * 255;

          const idx = 4 * (x + y * w);
          p.pixels[idx]     = col;
          p.pixels[idx + 1] = col;
          p.pixels[idx + 2] = 255 - col;
          p.pixels[idx + 3] = 255;
        }
      }

      p.updatePixels();

      // 공진기 경계 그리기 (r=R)
      p.noFill();
      p.stroke(255);
      p.strokeWeight(1);
      const radiusPx = (R / (2 * R * 2)) * w * 4; 
      // 위 좌표 매핑이 [-2R, 2R] 이므로 scale = w / (4R) -> Rpx = R * w / (4R) = w/4
      p.ellipse(w / 2, h / 2, w / 2, h / 2);

      p.noStroke();
      p.fill(255);
      p.textSize(14);
      p.textAlign(p.LEFT, p.TOP);
      p.text(`m = ${m},  l = ${l}`, 10, 10);
    };
  });
</script>
